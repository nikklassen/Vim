set nocompatible

execute pathogen#infect()
call pathogen#helptags()

filetype indent plugin on

" Enable syntax highlighting
syntax enable

" Better command-line completion
set wildmenu

" Completion settings
set completeopt=menu,longest

" Show partial commands in the last line of the screen
set showcmd
" Search commands

set hlsearch
set incsearch
set ignorecase
set smartcase

" Allow backspacing over autoindent, line breaks and start of insert action
set backspace=indent,eol,start

" When opening a new line and no filetype-specific indenting is enabled, keep
" the same indent as the line you're currently on. Useful for READMEs, etc.
set autoindent

set smartindent

" Stop certain movements from always going to the first character of a line.
" While this behaviour deviates from that of Vi, it does what most users
" coming from other editors would expect.
set nostartofline

" Always display the status line, even if only one window is displayed
set laststatus=2

" Instead of failing a command because of unsaved changes, instead raise a
" dialogue asking if you wish to save changed files.
set confirm

" Set the command window height to 2 lines, to avoid many cases of having to
" "press <Enter> to continue"
set cmdheight=2

" Display line numbers on the left
set number

set ruler

" Shorter timeout for escape keys
set tm=250

" conceal in insert (i), normal (n) and visual (v) modes
set concealcursor=inv
" hide concealed text completely unless replacement character is defined
set conceallevel=2

" Tell Vim not to highlight matching parentheses
let loaded_matchparen = 1

set path=.,/usr/include,,

set hidden

"------------------------------------------------------------
" Indentation options
"------------------------------------------------------------
set shiftwidth=4
set softtabstop=4
set tabstop=2

set expandtab
set smarttab
set shiftround
set nojoinspaces

"------------------------------------------------------------
" Mappings
"------------------------------------------------------------

map Y y$

" Map <C-L> (redraw screen) to also turn off search highlighting until the
" next search
nnoremap <C-L>      :nohl<CR><C-L>

nmap \<CR>   mrO<ESC>`r
imap \<CR>   <ESC>o

" Reindent whole file
nmap \=      mrgg=G`r

" Replace word under cursor with last yanked
nmap <leader>r      viw"0p
nmap <leader>R      V"0p

nmap <C-S> :w<CR>

nnoremap <silent> <space> @=(foldlevel('.') ? 'za' : "\<space>")<CR>

vnoremap <          <gv
vnoremap <leader><  <

vnoremap >          >gv
vnoremap <leader>>  >

nnoremap gp `[v`]

nnoremap <Left>     gT
nnoremap <Right>    gt
nnoremap <Up>       :lpr<CR>
nnoremap <Down>     :lne<CR>

nnoremap <M-Down>   ddp
nnoremap <M-Up>     ddkP

vnoremap <M-Down>   dpgv
vnoremap <M-Up>     dkPgv

nmap <leader>v      :tabe $MYVIMRC<CR>

set pastetoggle=<F5>

" build
nmap \m :w \| make<CR>

function! ExtendedHome()
    let column = col('.')
    normal! ^
    if column == col('.')
        normal! 0
    endif
endfunction

" Smart home
noremap <silent> <D-Left> :call ExtendedHome()<CR>

" 'Home' and 'End' for insert mode
inoremap <silent> <C-a> <C-O>:call ExtendedHome()<CR>
inoremap <C-e> <C-O>A

noremap <leader>c :cd %:p:h<CR><CR>
noremap <leader>p :!open -a Skim '%:p:r.pdf'<CR><CR>

" Search for the currently selected text
vnoremap // "sy/<C-R>s<CR>

function! ReplaceCurrentWord()
    let new_word = input('New word: ')
    if new_word == ''
        return
    endif

    let w = expand('<cword>')
    let new_line = substitute(getline('.'), w, new_word, 'g')
    call setline('.', new_line)
endfunction

nmap <leader>s :call ReplaceCurrentWord()<CR>

nmap <leader>i 0i<BS><CR>

"------------------------------------------------------------
" View Settings
"------------------------------------------------------------

function! SaveViewSettings()
    if expand('%:t') != ""
        mkview!
    endif
endfunction

function! LoadViewSettings()
    if expand('%:t') != ""
        silent loadview
    endif
endfunction

au BufWinLeave * call SaveViewSettings()
au BufWinEnter * call LoadViewSettings()

nnoremap <silent> <C-W>c :lcl \| close<CR>

" Hold onto marks for the last ten files
set viminfo='10

"------------------------------------------------------------
" Colour settings
"------------------------------------------------------------

hi Pmenu ctermbg=Blue
hi clear Conceal

if !has('gui_running')
    set background=dark
    colorscheme molokai
endif

function! GitSL()
    let head = fugitive#head()
    if head != ''
        return ' @ ' . head
    endif
    return ''
endfunction

set statusline=                          " clear the statusline for when vimrc is reloaded
set statusline+=[%n]\                    " buffer number
set statusline+=%<%.99f                  " file name
set statusline+=%{GitSL()}\ 
set statusline+=%h%m%r%w%q               " flags
set statusline+=%=                       " right align
set statusline+=%y\                      " file type
set statusline+=%-8(\ %l,%c\ %)          " offset

"------------------------------------------------------------
" File type specific settings
"------------------------------------------------------------

let g:tex_flavor='latex'

au BufRead,BufNewFile *.thor setf ruby

function! RunRuby()
    wa
    !ruby %
endfunction

" Run ruby with <A-R>
au BufRead,BufNewFile *.rb nmap Â® :call RunRuby()<CR>
au BufRead,BufNewFile *.rb set tags+=tags,~/.rbenv/versions/2.0.0-p195/tags

au BufRead,BufNewFile *.asm set syntax=mips
au BufRead,BufNewFile *.wlpp set syntax=cpp

au BufNewFile,BufReadPost *.log set filetype=log

let tags="tags,~/.vim/tags/cpp/tags,~/.vim/tags/gtest/tags"

au BufWritePost .vimrc source $MYVIMRC

" Keep the quickfix window small when there aren't many lines
au FileType qf call AdjustWindowHeight(3, 10)
function! AdjustWindowHeight(minheight, maxheight)
  exe max([min([line("$"), a:maxheight]), a:minheight]) . "wincmd _"
endfunction

"------------------------------------------------------------
" Plug-in settings
"------------------------------------------------------------

if exists( "vsvim_useeditordefaults" )
    set vsvim_useeditordefaults
endif

" EasyMotion
let g:EasyMotion_leader_key = '<leader>'
let g:EasyMotion_mapping_n = "<leader>x"

" Local vimrc
let g:localvimrc_sandbox=0
let g:localvimrc_ask=0

let g:qcc_format_menu = '${0}'
au BufRead /tmp/mutt* setlocal omnifunc=QueryCommandComplete

hi link EasyMotionTarget ErrorMsg
hi link EasyMotionShade  Comment

" Javascript indent
let g:SimpleJsIndenter_BriefMode = 1
let g:SimpleJsIndenter_CaseIndentLevel = -1

" Syntastic
let g:syntastic_mode_map = { 'passive_filetypes': ['tex', 'haskell'] }
let g:syntastic_auto_loc_list = 1
let g:syntastic_aggregate_errors = 1

let g:syntastic_less_checkers = ['lessc']

let g:syntastic_cpp_checkers = ['clang']
let g:syntastic_cpp_clang_args = "-std=c++11 -isystem ~/Programming/C++/gtest/include"

let g:syntastic_html_tidy_args = "-xml"

let g:syntastic_javascript_checkers = ['jshint', 'jscs']

let g:syntastic_typescript_checkers = ['tsc', 'tslint']
let g:syntastic_typescript_tsc_args = ' -t "es5" --noImplicitAny'

let g:syntastic_python_checkers = ['pylint']
let g:syntastic_python_pylint_args = '--rcfile=~/.pylintrc'

let g:syntastic_check_on_wq = 0
let g:syntastic_ignore_files = ['\.h$']

" Command-T
nnoremap <silent> <leader>o :CommandT<CR>
nnoremap <silent> <leader>b :CommandTBuffer<CR>
let g:CommandTWildIgnore=&wildignore . ",**/node_modules/*,*.o,*.pyc,*.hi"
let g:CommandTTraverseSCM = 'pwd'
let g:CommandTFileScanner = 'find'

" html indentation
let g:html_indent_inctags = "html,body,head,tbody,svg,g,script"

" YouCompleteMe
let g:ycm_semantic_triggers = {'html' : ['<'], 'js' : ['.'], 'haskell': ['.']}
let g:ycm_seed_identifiers_with_syntax = 1
let g:ycm_complete_in_strings = 0
let g:ycm_complete_in_comments = 0
let g:ycm_add_preview_to_completeopt = 1
let g:ycm_autoclose_preview_window_after_insertion = 1
let g:ycm_collect_identifiers_from_tags_files = 1
let g:ycm_min_num_of_chars_for_completion = 2
let g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'
let g:clang_library_path = "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib"
let g:ycm_confirm_extra_conf = 0
let g:ycm_filetype_blacklist = {
        \ 'pandoc' : 1,
        \ 'text': 1,
        \ 'tex': 1,
        \ 'gitcommit': 1,
        \}

au BufRead,BufEnter *.c,*.cpp,*.py,*.cs,*.ts map <F12> :YcmCompleter GoToDefinition<CR>

" NERDTree
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif
let NERDTreeIgnore = ['pyc$']

nmap <leader>n :NERDTreeToggle<CR>
nmap <leader>nf :NERDTreeFind<CR>

" delimitMate
let delimitMate_expand_cr = 1

" Tern
let tern_show_signature_in_pum = 1

" UltiSnips
let g:UltiSnipsExpandTrigger="<C-K>"
let g:UltiSnipsJumpForwardTrigger="<C-K>"
let g:UltiSnipsJumpBackwardTrigger="<C-J>"

" Vim2HS
let g:haskell_conceal = 0

" vim-latex
let g:tex_indent_brace=0
let g:tex_indent_items=0
let g:tex_conceal=""
imap <C-l> <Plug>IMAP_JumpForward
noremap <leader>q <Plug>Tex_InsertItemOnThisLine
